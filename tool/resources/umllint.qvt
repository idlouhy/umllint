transformation lint(source:uml, target:umllint) {
/* pattern: CommentReferencesNonOwner  */
top relation CommentReferencesNonOwner {

    checkonly domain source _comment:Comment {
        owner = _owner:Element{},
        annotatedElement = _reference:Element{}
    };
    
    enforce domain target _pattern : umllint::Pattern {
      id = '12',
      name = 'CommentReferencesNonOwner',
      binding = _binding1 : umllint::Binding {
        name = _comment.body,
        element = _comment    
      }
    };
    
   checkonly domain source _comment:Comment {
        owner = _owner:Element{},
        annotatedElement = _reference:Element{}
    };  
 
}


/* pattern: ClassifierNameIsPartOfGeneralName */
top relation ClassifierNameIsPartOfGeneralName {

    checkonly domain source _specific:Classifier {
        name = _specificName:String {},
        general = _general:Classifier {
            name = _generalName:String {}
        }
    };
    
    enforce domain target _pattern : umllint::Pattern {
      id = '40',
      name = 'ClassifierNameIsPartOfGeneralName',
      binding = _binding : umllint::Binding {
        name = _specific.name,
        element = _specific    
      }
    };

    when {
        _specificName.size() < _generalName.size();
        _generalName.substring(_generalName.size()-_specificName.size()+1, _generalName.size()) = _specificName;
    }
}

/* pattern: OperationHasReturnParameterNotNamedResult */
top relation OperationHasReturnParameterNotNamedResult {

    checkonly domain source _operation:Operation {
        ownedParameter = _parameter:Parameter {
            direction = ParameterDirectionKind::return
        }
    };
    
    enforce domain target _pattern : umllint::Pattern {
      id = '41',
      name = 'OperationHasReturnParameterNotNamedResult',
      binding = _binding : umllint::Binding {
        name = _operation.name,
        element = _operation    
      }
    };

    when {
        _parameter.name->isEmpty() or _parameter.name <> 'result';
    }
}

/* pattern: ParameterIsBooleanButDoesNotStartWithIs */
top relation ParameterIsBooleanButDoesNotStartWithIs {

    checkonly domain source _parameter:Parameter {
        type = _type:PrimitiveType {
            name = 'Boolean'
        }
    };

    enforce domain target _pattern : umllint::Pattern {
      id = '42',
      name = 'ParameterIsBooleanButDoesNotStartWithIs',
      binding = _binding : umllint::Binding {
        name = _parameter.name,
        element = _parameter    
      }
    };

    when {
        _parameter.direction <> ParameterDirectionKind::return;
        _parameter.name->isEmpty() or 
        _parameter.name.size() < 2 or 
        _parameter.name.substring(1,2) <> 'is';
    }
}

/* pattern: PropertyIsBooleanButDoesNotStartWithIs */
top relation PropertyIsBooleanButDoesNotStartWithIs {

    checkonly domain source _property:Property {
        type = _type:PrimitiveType {
            name = 'Boolean'
        }
    };
    
    enforce domain target _pattern : umllint::Pattern {
      id = '43',
      name = 'PropertyIsBooleanButDoesNotStartWithIs',
      binding = _binding : umllint::Binding {
        name = _property.name,
        element = _property    
      }
    };
    
    when {
        _property.namespace.name <> 'LiteralBoolean';
        _property.name->isEmpty() or 
        _property.name.size() < 2 or 
        _property.name.substring(1,2) <> 'is';
    }
}

/* pattern: PropertyDefaultLiteralHasType */
top relation PropertyDefaultLiteralHasType {

    checkonly domain source _property:Property {
        defaultValue = _default:LiteralSpecification {
            type = _type:Type {}
        }
    };

    enforce domain target _pattern : umllint::Pattern {
      id = '44',
      name = 'PropertyDefaultLiteralHasType',
      binding = _binding : umllint::Binding {
        name = _property.name,
        element = _property    
      }
    };
}


/* pattern: AssociationIsAbstract */
top relation AssociationIsAbstract {

    checkonly domain source _association:Association {
        isAbstract = true
    };

    enforce domain target _pattern : umllint::Pattern {
      id = '45',
      name = 'AssociationIsAbstract',
      binding = _binding : umllint::Binding {
        name = _association.name,
        element = _association    
      }
    };
}


  query haveConsistentPropertySubsetting(_subset: Property, _superset: Property) : Boolean {
    _subset.type.conformsTo(_superset.type) and
    un2int(_subset.upper) <= un2int(_superset.upper) and
    ((_superset.isComposite() and _superset.isDerivedUnion) implies _subset.isComposite())
  }

  query un2int (_un : Integer) : Integer {
    if isUnlimited(_un) then 2147483647 else _un endif
  }

  query isUnlimited(_un : Integer) : Boolean {
    _un = -1
  }
}
